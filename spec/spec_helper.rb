require 'timeout'
require 'socket'
require 'vncrec'
require 'active_support/core_ext/numeric/time'

# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause this
# file to always be loaded, without a need to explicitly require it in any files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, make a
# separate helper file that requires this one and then use it only in the specs
# that actually need it.
#
# The `.rspec` file also contains a few flags that are not defaults but that
# users commonly want.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  config.exclusion_filter = :interactive, :skip
  config.filter_run :focus
  config.run_all_when_everything_filtered = true

  config.before(:all) do
    `rake gem`
  end

  config.before(:each, port: true) do
    free_port 5900
  end

  config.after(:each, port: true) do
    free_port 5900
  end

  config.after(:each) do
    kill_children
    `rake clean &>/dev/null`
    `rm -rf file* &>/dev/null`
  end

  config.after(:each, vnc: true) do
    stop_vnc_server
  end

  config.after(:all) do
    `rake clean`
    `kill -ABRT \`pgrep x11vnc\` &>/dev/null`
    begin
      `kill -INT \`pgrep ruby\` \`pgrep vncrec\` &>/dev/null`
      kill_children
    rescue SignalException
    end
    `xset r &>/dev/null`
  end
end

def get_free_port
  gen = proc do
    (rand * 1000).to_i + 5001
  end
  port = gen.call
  port = gen.call while port_in_use? port
  port
end

def port_avail?(port)
  lines = File.readlines('/proc/net/tcp')
  rx = /\d+: \d+:(?<port>\w+)/
  !lines.map do |line|
    m = line.match(rx)
    m[:port].to_i(16) if m
  end.include?(port)
end

def port_in_use?(port)
  !port_avail?(port)
end

def pid_using_port(port)
  lines = `lsof -i:#{port}`.lines
  return nil if lines.empty?
  col = lines[0].split(' ').index('PID')
  lines.drop(1)[0].split(' ')[col].to_i
end

def free_port(port)
  p = pid_using_port(port)
  if Process.pid == p
    close_socket_descriptors
    return
  end
  `kill -INT #{p} &>/dev/null; sleep 1`
  return unless port_in_use?(port)
  `kill -QUIT #{p} &>/dev/null; sleep 1`
  return unless port_in_use?(port)
  `kill -KILL #{p} &>/dev/null; sleep 1`
end

def kill_children(sig = 'INT')
  chids =  `ps --ppid #{Process.pid} 2>/dev/null`
    .lines.drop(1).map { |l| l.split(/\W+/)[0] }
  chids.each do |v|
    `kill -#{sig} #{v} 2>/dev/null`
  end
end

def close_socket_descriptors
  ObjectSpace.each_object(TCPSocket) do |o|
    begin
      o.close unless o.closed?
    rescue
    end
  end
end

def read_process_timeout(cmd = '', tout = 0.2)
  `rm -f log`

  pid = fork do
    exec "#{cmd} &>log"
  end

  sleep 2
  `kill -INT #{pid}`
  sleep 0.3

  begin
    Timeout.timeout(0.5) do
      Process.waitpid(pid)
    end
  rescue Timeout::Error
    `kill -TERM #{pid}`
  end

  f = File.open('log', 'r')
  res =  f.read_nonblock(1024)
  f.close
  `rm -f log`
  res
end

def expect_timeout(time, &block)
  expect do
    Timeout.timeout(time) do
      block.call
    end
  end.to raise_error Timeout::Error
end

def expect_no_timeout(time, &block)
  expect do
    Timeout.timeout(time) do
      block.call
    end
  end.not_to raise_error
end

def launch_vnc_server(port, host = '0.0.0.0', debug = false)
  fork do
    `x11vnc --connect #{host}:#{port} #{debug ? nil : '&>/dev/null'}`
  end
end

def stop_vnc_server
  `killall x11vnc &>/dev/null`
  'killall -ABRT x11vnc &>/dev/null'
end
